import axios from 'axios';
import {BASE_URL, DEFAULT_HEADERS, FORM_DATA_HEADERS, ERROR_MESSAGES, DEFAULT_TIMEOUT} from './api';
import authService from './AuthService';
import AsyncStorage from "@react-native-async-storage/async-storage";

class CreatePostService {
    constructor() {
        // ƒêi·ªÅu ch·ªânh baseURL d·ª±a tr√™n m√¥i tr∆∞·ªùng
        let apiBaseUrl = BASE_URL;

        console.log('API URL ƒë∆∞·ª£c s·ª≠ d·ª•ng:', apiBaseUrl);

        this.api = axios.create({
            baseURL: apiBaseUrl,
            timeout: DEFAULT_TIMEOUT,
            headers: DEFAULT_HEADERS,
        });

        // Th√™m interceptor ƒë·ªÉ t·ª± ƒë·ªông th√™m token v√†o m·ªói request
        this.api.interceptors.request.use(async (config) => {
            try {
                const token = await authService.getBearerToken();
                if (token) {
                    config.headers.Authorization = token;
                }
                return config;
            } catch (error) {
                console.error('L·ªói khi l·∫•y token:', error);
                return config;
            }
        });
    }

    // Helper ƒë·ªÉ x·ª≠ l√Ω l·ªói
    handleError(error) {
        console.error('API Error:', error);

        if (error.response) {
            // L·ªói c√≥ response t·ª´ server
            const status = error.response.status;
            const message = error.response.data?.message || ERROR_MESSAGES[status] || ERROR_MESSAGES.default;

            throw new Error(message);
        } else if (error.request) {
            // L·ªói kh√¥ng c√≥ response t·ª´ server
            throw new Error(ERROR_MESSAGES.default);
        } else {
            // L·ªói kh√°c
            throw new Error(error.message || ERROR_MESSAGES.default);
        }
    }

    // Helper ƒë·ªÉ l·∫•y headers ph√π h·ª£p
    getHeaders(isFormData = false) {
        return isFormData ? FORM_DATA_HEADERS : DEFAULT_HEADERS;
    }

    // T·∫°o b√†i ƒëƒÉng m·ªõi
    async createPost(postData) {
        try {
            // Log request
            console.log('ƒêang g·ª≠i request t·∫°o b√†i ƒëƒÉng v·ªõi d·ªØ li·ªáu:', postData);

            // T·∫°o FormData ƒë·ªÉ upload ·∫£nh v√† d·ªØ li·ªáu
            const formData = new FormData();

            // Th√™m c√°c tr∆∞·ªùng t·ª´ postData
            if (postData.content) {
                formData.append('content', postData.content);
            }

            // Th√™m ·∫£nh n·∫øu c√≥
            if (postData.imageFile) {
                console.log('Th√™m file:', postData.imageFile);
                // ƒê·∫£m b·∫£o ƒë√∫ng c·∫•u tr√∫c cho React Native FormData
                formData.append('imageFile', {
                    uri: postData.imageFile.uri,
                    type: postData.imageFile.type || 'image/jpeg',
                    name: postData.imageFile.name || 'image.jpg'
                });
            }

            // Th√™m lo·∫°i b√†i ƒëƒÉng (n·∫øu c√≥)
            if (postData.type) {
                formData.append('type', postData.type);
            }

            console.log('FormData ƒë∆∞·ª£c t·∫°o:', JSON.stringify(formData));

            // Log URL ƒë·∫ßy ƒë·ªß
            console.log('URL request:', this.api.defaults.baseURL + '/posts');

            // M·ªü r·ªông timeout cho upload
            const response = await this.api.post('/posts', formData, {
                headers: {
                    ...this.getHeaders(true),
                    'Content-Type': 'multipart/form-data'
                },
                timeout: 60000 // TƒÉng timeout l√™n 60 gi√¢y
            });

            console.log('Response t·ª´ createPost:', response.data);
            return response.data;
        } catch (error) {
            console.error('L·ªói khi t·∫°o b√†i ƒëƒÉng:', error);
            this.handleError(error);
        }
    }

    // C·∫≠p nh·∫≠t b√†i ƒëƒÉng
    async updatePost(postId, postData) {
        try {
            const formData = new FormData();

            if (postData.content) {
                formData.append('content', postData.content);
            }

            if (postData.imageFile) {
                formData.append('imageFile', {
                    uri: postData.imageFile.uri,
                    type: postData.imageFile.type || 'image/jpeg',
                    name: postData.imageFile.name || 'image.jpg'
                });
            }

            if (postData.type) {
                formData.append('type', postData.type);
            }

            const response = await this.api.put(`/posts/${postId}`, formData, {
                headers: {
                    ...this.getHeaders(true),
                    'Content-Type': 'multipart/form-data'
                },
                timeout: 30000 // TƒÉng timeout cho upload
            });

            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }

    // X√≥a b√†i ƒëƒÉng
    async deletePost(postId) {
        try {
            await this.api.delete(`/posts/${postId}`);
            return true;
        } catch (error) {
            this.handleError(error);
        }
    }

    // L·∫•y chi ti·∫øt b√†i ƒëƒÉng
    async getPostById(postId) {
        try {
            const response = await this.api.get(`/posts/${postId}`);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }

    // L·∫•y b√†i ƒëƒÉng c·ªßa ng∆∞·ªùi d√πng
    async getPostsByUser(userId) {
        try {
            const response = await this.api.get(`/posts/user/${userId}`);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }

    // T√¨m ki·∫øm b√†i ƒëƒÉng
    async searchPosts(keyword) {
        try {
            const response = await this.api.get(`/posts/search`, {
                params: { keyword }
            });
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    // bai viet cua nguoi dung
    async getCurrentUserPosts(page = 0, limit = 10, order = 'desc') {
        try {
            console.log(`ƒêang g·ªçi API l·∫•y b√†i ƒëƒÉng c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i: /posts/me?page=${page}&limit=${limit}&order=${order}`);

            const response = await this.api.get('/posts/me', {
                params: {
                    page,
                    limit,
                    order
                }
            });

            console.log('Response t·ª´ getCurrentUserPosts:', response.data);
            return response.data;
        } catch (error) {
            console.error('L·ªói khi l·∫•y b√†i ƒëƒÉng c·ªßa ng∆∞·ªùi d√πng hi·ªán t·∫°i:', error);
            this.handleError(error);
        }
    }

    // Trong CreatePostService.js
    // S·ª≠a ƒë·ªïi h√†m checkPostOwnership trong CreatePostService.js
    async checkPostOwnership(postId) {
        try {
            console.log('üîç B·∫Øt ƒë·∫ßu ki·ªÉm tra quy·ªÅn s·ªü h·ªØu b√†i vi·∫øt:', postId);

            // Ki·ªÉm tra postId c√≥ h·ª£p l·ªá kh√¥ng
            if (!postId) {
                console.log('‚ùå PostId kh√¥ng h·ª£p l·ªá');
                return false;
            }

            // L·∫•y token t·ª´ AsyncStorage
            const token = await AsyncStorage.getItem('accessToken');
            if (!token) {
                console.log('‚ùå Kh√¥ng c√≥ token');
                return false;
            }

            // T·∫°o c√°c promise ƒë·ªÉ th·ª±c hi·ªán song song
            const promises = [];

            // Promise 1: L·∫•y th√¥ng tin b√†i vi·∫øt
            const getPostPromise = this.getPostById(postId)
                .then(postData => {
                    console.log('üìÑ Chi ti·∫øt b√†i vi·∫øt:', JSON.stringify(postData, null, 2));
                    return postData;
                })
                .catch(error => {
                    console.error('‚ùå L·ªói khi l·∫•y chi ti·∫øt b√†i vi·∫øt:', error);
                    throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin b√†i vi·∫øt');
                });

            // Promise 2: L·∫•y th√¥ng tin user hi·ªán t·∫°i
            const getUserPromise = this.api.get('/v1/users/profile')
                .then(response => {
                    if (!response?.data) {
                        throw new Error('Response kh√¥ng h·ª£p l·ªá t·ª´ API profile');
                    }
                    console.log('üë§ Th√¥ng tin ng∆∞·ªùi d√πng hi·ªán t·∫°i:', JSON.stringify(response.data, null, 2));
                    return response.data;
                })
                .catch(error => {
                    console.error('‚ùå L·ªói khi l·∫•y th√¥ng tin ng∆∞·ªùi d√πng:', error);
                    if (error.response) {
                        console.error('üìä Chi ti·∫øt l·ªói t·ª´ server:', error.response.data);
                        console.error('üìà Status code:', error.response.status);
                    }
                    throw new Error('Kh√¥ng th·ªÉ l·∫•y th√¥ng tin ng∆∞·ªùi d√πng');
                });

            // Th·ª±c hi·ªán c·∫£ hai promises song song v·ªõi timeout
            const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error('API timeout after 8 seconds')), 8000)
            );

            const [postData, currentUser] = await Promise.race([
                Promise.all([getPostPromise, getUserPromise]),
                timeoutPromise
            ]);

            // Ki·ªÉm tra d·ªØ li·ªáu c√≥ h·ª£p l·ªá kh√¥ng
            if (!postData) {
                console.log('‚ùå Kh√¥ng t√¨m th·∫•y b√†i vi·∫øt');
                return false;
            }

            if (!currentUser) {
                console.log('‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin ng∆∞·ªùi d√πng');
                return false;
            }

            // L·∫•y ID v·ªõi nhi·ªÅu fallback options
            const currentUserId = currentUser?.id ||
                currentUser?.userId ||
                currentUser?.user_id;

            const postOwnerId = postData?.userRes?.id ||
                postData?.user?.id ||
                postData?.userId ||
                postData?.user_id ||
                postData?.authorId;

            console.log('üîÑ So s√°nh ID:', {
                currentUserId,
                postOwnerId,
                currentUserType: typeof currentUserId,
                postOwnerType: typeof postOwnerId,
                currentUserObject: currentUser,
                postDataUserRes: postData?.userRes
            });

            // Ki·ªÉm tra c·∫£ hai ID ƒë·ªÅu t·ªìn t·∫°i v√† h·ª£p l·ªá
            if (!currentUserId || !postOwnerId) {
                console.log('‚ùå M·ªôt trong c√°c ID kh√¥ng t·ªìn t·∫°i');
                console.log('üìã Debug info:', {
                    hasCurrentUserId: !!currentUserId,
                    hasPostOwnerId: !!postOwnerId,
                    currentUserKeys: Object.keys(currentUser || {}),
                    postDataKeys: Object.keys(postData || {})
                });
                return false;
            }

            // Chuy·ªÉn ƒë·ªïi sang string v√† so s√°nh
            const currentUserIdStr = String(currentUserId).trim();
            const postOwnerIdStr = String(postOwnerId).trim();

            const isOwner = currentUserIdStr === postOwnerIdStr;

            console.log('‚úÖ K·∫øt qu·∫£ ki·ªÉm tra quy·ªÅn:', {
                isOwner,
                currentUserIdStr,
                postOwnerIdStr,
                exactMatch: currentUserIdStr === postOwnerIdStr
            });

            return isOwner;

        } catch (error) {
            console.error('üí• L·ªói t·ªïng qu√°t khi ki·ªÉm tra quy·ªÅn s·ªü h·ªØu b√†i vi·∫øt:', error);

            // Log chi ti·∫øt c√°c lo·∫°i l·ªói kh√°c nhau
            if (error.name === 'TypeError') {
                console.error('üîß TypeError - c√≥ th·ªÉ do object undefined:', error.message);
            } else if (error.code === 'NETWORK_ERROR') {
                console.error('üåê Network error:', error.message);
            } else if (error.response) {
                console.error('üî¥ HTTP Error Response:', {
                    status: error.response.status,
                    statusText: error.response.statusText,
                    data: error.response.data
                });
            } else if (error.request) {
                console.error('üì° Request error - no response received:', error.request);
            }

            // Tr·∫£ v·ªÅ false thay v√¨ throw error ƒë·ªÉ kh√¥ng crash app
            return false;
        }
    }

// C·∫≠p nh·∫≠t ph∆∞∆°ng th·ª©c getFeedPosts trong CreatePostService.js
    async getFeedPosts(page = 0, size = 10, order = 'desc') {
        try {
            console.log(`ƒêang g·ªçi API l·∫•y feed b√†i ƒëƒÉng: /posts/feed?page=${page}&size=${size}&order=${order}`);

            const response = await this.api.get(`/posts/feed`, {
                params: { page, size, order }
            });

            console.log('Response t·ª´ getFeedPosts:', response.data);

            // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu b√†i ƒëƒÉng ƒë·ªÉ x·ª≠ l√Ω URL h√¨nh ·∫£nh
            const content = this.processPostsImageUrls(response.data || []);

            // N·∫øu response.data l√† m·∫£ng, t·ª©c l√† n√≥ kh√¥ng ph·∫£i l√† d·ªØ li·ªáu ph√¢n trang
            if (Array.isArray(response.data)) {
                return {
                    content: content,
                    totalElements: content.length,
                    totalPages: 1,
                    last: true,
                    number: page,
                    size: size
                };
            }

            // N·∫øu response.data l√† ƒë·ªëi t∆∞·ª£ng ph√¢n trang
            return {
                content: content,
                totalElements: response.data.totalElements,
                totalPages: response.data.totalPages,
                last: response.data.last,
                number: response.data.number,
                size: response.data.size
            };
        } catch (error) {
            console.error('L·ªói khi l·∫•y feed b√†i ƒëƒÉng:', error);
            this.handleError(error);
        }
    }

// Th√™m h√†m m·ªõi ƒë·ªÉ x·ª≠ l√Ω URL h√¨nh ·∫£nh cho t·∫•t c·∫£ b√†i ƒëƒÉng
    processPostsImageUrls(posts) {
        // Ki·ªÉm tra n·∫øu posts l√† ƒë·ªëi t∆∞·ª£ng ph√¢n trang
        if (posts && posts.content) {
            posts = posts.content;
        }

        // N·∫øu posts kh√¥ng ph·∫£i l√† m·∫£ng, tr·∫£ v·ªÅ m·∫£ng r·ªóng
        if (!Array.isArray(posts)) {
            return [];
        }

        return posts.map(post => {
            // T·∫°o URL h√¨nh ·∫£nh ƒë·∫ßy ƒë·ªß n·∫øu c√≥ imageUrl
            if (post.imageUrl) {
                post.fullImageUrl = this.createImageUrl(post.imageUrl);
            }
            return post;
        });
    }

// Th√™m h√†m ƒë·ªÉ t·∫°o URL h√¨nh ·∫£nh t·ª´ ƒë∆∞·ªùng d·∫´n
    createImageUrl(path) {
        if (!path) return null;

        try {
            // Lo·∫°i b·ªè d·∫•u / ·ªü ƒë·∫ßu n·∫øu c√≥
            const cleanPath = path.replace(/^\//, '');

            // T·∫°o URL ho√†n ch·ªânh d·ª±a tr√™n c·∫•u h√¨nh API
            const baseUrl = this.api.defaults.baseURL || BASE_URL;
            const fullUrl = `${baseUrl}/files/image?bucketName=thanh&path=${encodeURIComponent(cleanPath)}`;

            return fullUrl;
        } catch (error) {
            console.error('L·ªói khi t·∫°o URL h√¨nh ·∫£nh:', error);
            return null;
        }
    }

    // Th√≠ch/b·ªè th√≠ch b√†i ƒëƒÉng
    async toggleLike(postId) {
        try {
            const response = await this.api.post(`/posts/${postId}/like`);
            return response.data;
        } catch (error) {
            this.handleError(error);
        }
    }
    async fetchUserPosts(pageNumber = 0, limit = 10, shouldRefresh = false) {
        try {
            console.log(`ƒêang t·∫£i b√†i ƒëƒÉng: trang ${pageNumber}, gi·ªõi h·∫°n ${limit}`);

            const response = await this.api.get('/posts/me', {
                params: {
                    page: pageNumber,
                    limit: limit,
                    order: 'desc'
                }
            });

            // Log to√†n b·ªô response ƒë·ªÉ ki·ªÉm tra
            console.log('Response t·ª´ fetchUserPosts:', JSON.stringify(response.data, null, 2));

            // Tr·∫£ v·ªÅ object ch·ª©a th√¥ng tin ph√¢n trang v√† danh s√°ch b√†i ƒëƒÉng
            return {
                posts: response.data.content || [],
                isLastPage: response.data.last,
                totalElements: response.data.totalElements,
                currentPage: response.data.number
            };
        } catch (error) {
            console.error('L·ªói khi l·∫•y b√†i ƒëƒÉng c·ªßa ng∆∞·ªùi d√πng:', error);

            // N·∫øu c√≥ response t·ª´ server, log chi ti·∫øt l·ªói
            if (error.response) {
                console.error('Chi ti·∫øt l·ªói:', error.response.data);
            }

            // N√©m l·ªói ƒë·ªÉ component c√≥ th·ªÉ x·ª≠ l√Ω
            throw error;
        }
    }
}

export default  new CreatePostService();
